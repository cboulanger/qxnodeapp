{"ts":1342958089418,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n################################################################################\n#\n#  qooxdoo - the new era of web development\n#\n#  http://qooxdoo.org\n#\n#  Copyright:\n#    2008 - 2010 1&1 Internet AG, Germany, http://www.1und1.de\n#\n#  License:\n#    LGPL: http://www.gnu.org/licenses/lgpl.html\n#    EPL: http://www.eclipse.org/org/documents/epl-v10.php\n#    See the LICENSE file in the project's top-level directory for details.\n#\n#  Authors:\n#    * Fabian Jakobs (fjakobs)\n#    * Andreas Ecker (ecker)\n#\n################################################################################\n\nimport re, os, sys, optparse, shutil, errno, stat, codecs, glob, types\nfrom string import Template\nfrom collections import defaultdict\n\nimport qxenviron\nfrom ecmascript.frontend import lang\nfrom generator.runtime.Log import Log\nfrom misc import Path\n\n\nSCRIPT_DIR    = qxenviron.scriptDir\nFRAMEWORK_DIR = os.path.normpath(os.path.join(SCRIPT_DIR, os.pardir, os.pardir))\nSKELETON_DIR  = unicode(os.path.normpath(os.path.join(FRAMEWORK_DIR, \"component\", \"skeleton\")))\nGENERATE_PY   = unicode(os.path.normpath(os.path.join(FRAMEWORK_DIR, \"tool\", \"data\", \"generator\", \"generate.tmpl.py\")))\nAPP_DIRS      = [x for x in os.listdir(SKELETON_DIR) if not re.match(r'^\\.',x)]\n\nR_ILLEGAL_NS_CHAR = re.compile(r'(?u)[^\\.\\w]')  # allow unicode, but disallow $\nR_SHORT_DESC      = re.compile(r'(?m)^short::\\s*(.*)$')  # to search \"short:: ...\" in skeleton's 'readme.txt'\nR_COPY_FILE       = re.compile(r'(?m)^copy_file::\\s*(.*)$')  # special files to copy from SDK for this skeleton\nQOOXDOO_VERSION   = ''  # will be filled later\n\n\ndef getAppInfos():\n    appInfos = {}\n    for dir_ in APP_DIRS:\n        readme = os.path.join(SKELETON_DIR, dir_, \"readme.txt\")\n        appinfo = defaultdict(unicode)\n        if os.path.isfile(readme):\n            cont = open(readme, \"rU\").readlines()\n            for line in cont:\n                # short::\n                mo   = R_SHORT_DESC.search(line)\n                if mo:\n                    appinfo['short'] = mo.group(1)\n                # copy_file:: - could be multiple\n                mo   = R_COPY_FILE.search(line)\n                if mo:\n                    if not isinstance(appinfo['copy_file'], types.ListType):\n                        appinfo['copy_file'] = []\n                    appinfo['copy_file'].append(mo.group(1))\n        appInfos[dir_] = appinfo\n    return appInfos\n\nAPP_INFOS = getAppInfos()\n\n\ndef getQxVersion():\n    global QOOXDOO_VERSION\n    versionFile = os.path.join(FRAMEWORK_DIR, \"version.txt\")\n    version = codecs.open(versionFile,\"r\", \"utf-8\").read()\n    version = version.strip()\n    QOOXDOO_VERSION = version\n    return\n\n\n\ndef createApplication(options):\n    out = options.out\n    if sys.platform == 'win32' and re.match( r'^[a-zA-Z]:$', out):\n        out = out + '\\\\'\n    else:\n        out = os.path.expanduser(out)\n\n    if not os.path.isdir(out):\n        if os.path.isdir(normalizePath(out)):\n            out = normalizePath(out)\n        else:\n            console.error(\"Output directory '%s' does not exist\" % out)\n            sys.exit(1)\n\n\n    outDir = os.path.join(out, options.name)\n    is_contribution = options.type == \"contribution\"\n    appDir = os.path.join(outDir, \"trunk\") if is_contribution else outDir\n    app_infos = APP_INFOS[options.type]\n    demo_suffix = \"demo/default\" if is_contribution else ''\n\n    # copy the template structure\n    copySkeleton(options.skeleton_path, options.type, outDir, options.namespace)\n\n    # individual copies from tool/data\n    # generate.py\n    shutil.copy(GENERATE_PY, appDir)\n    if is_contribution:\n        shutil.copy(GENERATE_PY, os.path.join(appDir, *demo_suffix.split(\"/\")))\n\n    # copy files\n    if isinstance(app_infos['copy_file'], types.ListType):\n        for pair in app_infos['copy_file']:\n            src, dest = pair.split(None, 1)\n            src_path = os.path.join(FRAMEWORK_DIR, src)\n            dst_path = os.path.join(appDir, dest)\n            if os.path.isfile(src_path):\n                if not os.path.isdir(os.path.dirname(dst_path)):\n                    os.makedirs(os.path.dirname(dst_path))\n                shutil.copy(src_path, dst_path)\n            else:\n                print >>sys.stderr, \"Warning: Source file \\\"%s\\\" not available - please see the skeleton's readme.txt\" % src_path\n\n    # rename files\n    rename_folders(appDir, options.namespace)\n    if options.type == \"contribution\":\n        rename_folders(os.path.join(appDir, \"demo\", \"default\"), options.namespace)\n\n    # clean out unwanted\n    cleanSkeleton(appDir)\n\n    # patch file contents\n    patchSkeleton(appDir, FRAMEWORK_DIR, options)\n\n    return\n\ndef rename_folders(root_dir, namespace):\n    console.log(\"Renaming stuff...\")\n    # rename name space parts of paths\n\n    # rename in class path\n    source_dir = os.path.join(root_dir, \"source\", \"class\", \"custom\")\n    out_dir    = os.path.join(root_dir, \"source\", \"class\")\n    expand_dir(source_dir, out_dir, namespace)\n\n    # rename in resource path\n    resource_dir = os.path.join(root_dir, \"source\", \"resource\", \"custom\")\n    out_dir      = os.path.join(root_dir, \"source\", \"resource\")\n    expand_dir(resource_dir, out_dir, namespace)\n\n    # rename in script path\n    script_dir   = os.path.join(root_dir, \"source\", \"script\")\n    script_files = glob.glob(os.path.join(script_dir, \"custom.*js\")) \n    if script_files:\n        for script_file in script_files:\n            os.rename(script_file, script_file.replace(\"custom\", namespace))\n\n\ndef copySkeleton(skeleton_path, app_type, dir_, namespace):\n    console.log(\"Copy skeleton into the output directory: %s\" % dir_)\n\n    template = os.path.join(skeleton_path, app_type)\n    if not os.path.isdir(template):\n        console.error(\"Unknown application type '%s'.\" % app_type)\n        sys.exit(1)\n\n    try:\n        shutil.copytree(template, dir_)\n    except OSError:\n        console.error(\"Failed to copy skeleton, maybe the directory already exists\")\n        sys.exit(1)\n\ndef cleanSkeleton(dir_):\n    #clean svn directories\n    for root, dirs, files in os.walk(dir_, topdown=False):\n        if \".svn\" in dirs:\n            filename = os.path.join(root, \".svn\")\n            shutil.rmtree(filename, ignore_errors=False, onerror=handleRemoveReadonly)\n\n\ndef expand_dir(indir, outroot, namespace):\n    \"appends namespace parts to outroot, and renames indir to the last part\"\n    if not (os.path.isdir(indir) and os.path.isdir(outroot)):\n        return\n    ns_parts = namespace.split('.')\n    target   = outroot\n    for part in ns_parts:\n        target = os.path.join(target, part)\n        if part == ns_parts[-1]: # it's the last part\n            os.rename(indir, target)\n        else:\n            os.mkdir(target)\n\ndef patchSkeleton(dir_, framework_dir, options):\n    absPath = normalizePath(framework_dir)\n    if absPath[-1] == \"/\":\n        absPath = absPath[:-1]\n\n    if sys.platform == 'cygwin':\n        if re.match( r'^\\.{1,2}\\/', dir_ ):\n            relPath = Path.rel_from_to(normalizePath(dir_), framework_dir)\n        elif re.match( r'^/cygdrive\\b', dir_):\n            relPath = Path.rel_from_to(dir_, framework_dir)\n        else:\n            relPath = Path.rel_from_to(normalizePath(dir_), normalizePath(framework_dir))\n    else:\n        relPath = Path.rel_from_to(normalizePath(dir_), normalizePath(framework_dir))\n\n    relPath = re.sub(r'\\\\', \"/\", relPath)\n    if relPath[-1] == \"/\":\n        relPath = relPath[:-1]\n\n    if not os.path.isdir(os.path.join(dir_, relPath)):\n        console.error(\"Relative path to qooxdoo directory is not correct: '%s'\" % relPath)\n        sys.exit(1)\n\n    if options.type == \"contribution\":\n        relPath = os.path.join(os.pardir, os.pardir, \"qooxdoo\", QOOXDOO_VERSION)\n        relPath = re.sub(r'\\\\', \"/\", relPath)\n\n    for root, dirs, files in os.walk(dir_):\n        for file in files:\n            split = file.split(\".\")\n            if len(split) >= 3 and split[-2] == \"tmpl\":\n                outFile = os.path.join(root, \".\".join(split[:-2] + split[-1:]))\n                inFile = os.path.join(root, file)\n                console.log(\"Patching file '%s'\" % outFile)\n\n                #config = MyTemplate(open(inFile).read())\n                config = Template(open(inFile).read())\n                out = open(outFile, \"w\")\n                out.write(\n                    config.substitute({\n                        \"Name\": options.name,\n                        \"Namespace\": options.namespace,\n                        \"NamespacePath\" : (options.namespace).replace('.', '/'),\n                        \"REL_QOOXDOO_PATH\": relPath,\n                        \"ABS_QOOXDOO_PATH\": absPath,\n                        \"QOOXDOO_VERSION\": QOOXDOO_VERSION,\n                        \"Cache\" : options.cache,\n                    }).encode('utf-8')\n                )\n                out.close()\n                os.remove(inFile)\n\n    for root, dirs, files in os.walk(dir_):\n        for file in [file for file in files if file.endswith(\".py\")]:\n            os.chmod(os.path.join(root, file), (stat.S_IRWXU\n                                               |stat.S_IRGRP |stat.S_IXGRP\n                                               |stat.S_IROTH |stat.S_IXOTH)) # 0755\n\n\n\ndef handleRemoveReadonly(func, path, exc):\n# For Windows the 'readonly' must not be set for resources to be removed\n    excvalue = exc[1]\n    if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:\n        os.chmod(path, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO) # 0777\n        func(path)\n    else:\n        raise\n\n\ndef normalizePath(path):\n# Fix Windows annoyance to randomly return drive letters uppercase or lowercase.\n# Under Cygwin the user could also supply a lowercase drive letter. For those\n# two systems, the drive letter is always converted to uppercase, the remaining\n# path to lowercase\n\n    if not sys.platform == 'win32' and not sys.platform == 'cygwin':\n        return path\n\n    path = re.sub(r'\\\\+', \"/\", path)\n\n    if sys.platform == 'cygwin':\n        search = re.match( r'^/cygdrive/([a-zA-Z])(/.*)$', path)\n        if search:\n            return search.group(1).upper() + \":\" + search.group(2).lower()\n\n    search = re.match( r'^([a-zA-Z])(:.*)$', path )\n    if search:\n        return search.group(1).upper() + search.group(2).lower()\n\n    return path\n\n\ndef checkNamespace(options):\n\n    # check availability and spelling\n    if not options.namespace:\n        if R_ILLEGAL_NS_CHAR.search(options.name):\n            convertedName = R_ILLEGAL_NS_CHAR.sub(\"_\", options.name)\n            console.log(\"WARNING: Converted illegal characters in name (from %s to %s)\" % (options.name, convertedName))\n            options.name = convertedName\n            options.namespace = convertedName.lower()\n        else:\n            options.namespace = options.name.lower()\n        \n    else:\n        options.namespace = options.namespace.decode('utf-8')\n        if R_ILLEGAL_NS_CHAR.search(options.namespace):\n            convertedNamespace = R_ILLEGAL_NS_CHAR.sub(\"_\", options.namespace)\n            console.log(\"WARNING: Converted illegal characters in namespace (from %s to %s)\" % (options.namespace, convertedNamespace))\n            options.namespace = convertedNamespace\n\n    for namepart in options.namespace.split(\".\"):\n        # check well-formed identifier\n        if not re.match(lang.IDENTIFIER_REGEXP, namepart):\n            console.error(\"Name space part must be a legal JS identifier, but is not: '%s'\" % namepart)\n            sys.exit(1)\n\n        # check reserved words\n        if namepart in (lang.GLOBALS + lang.RESERVED.keys()):\n            console.error(\"JS reserved word '%s' is not allowed as name space part\" % namepart)\n            sys.exit(1)\n\n\ndef skeletonsHelpString():\n    helpString = \"Type of the application to create, one of: \"\n    helpString += str(map(str, sorted(APP_INFOS.keys()))) + \".\" \n    helpString += str(\"; \".join([\"'%s' -- %s\" % (x, y) for x,y in sorted([(k,i['short']) for k,i in APP_INFOS.items()])])) \n    helpString += \". (Default: %default)\"\n    return helpString\n\n\ndef main():\n    parser = optparse.OptionParser()\n\n    parser.set_usage('''\\\n%prog --name APPLICATIONNAME [--out DIRECTORY]\n                             [--namespace NAMESPACE] [--type TYPE]\n                             [-logfile LOGFILE] [--skeleton-path PATH]\n\nScript to create a new qooxdoo application.\n\nExample: For creating a regular GUI application \\'myapp\\' you could execute:\n  %prog --name myapp''')\n\n    parser.add_option(\n        \"-n\", \"--name\", dest=\"name\", metavar=\"APPLICATIONNAME\",\n        help=\"Name of the application. An application folder with identical name will be created. (Required)\"\n    )\n    parser.add_option(\n        \"-o\", \"--out\", dest=\"out\", metavar=\"DIRECTORY\", default=\".\",\n        help=\"Output directory for the application folder. (Default: %default)\"\n    )\n    parser.add_option(\n        \"-s\", \"--namespace\", dest=\"namespace\", metavar=\"NAMESPACE\", default=None,\n        help=\"Applications's top-level namespace. (Default: APPLICATIONNAME)\"\n    )\n    parser.add_option(\n        \"-t\", \"--type\", dest=\"type\", metavar=\"TYPE\", default=\"desktop\",\n        help=skeletonsHelpString()\n     )\n    parser.add_option(\n        \"-l\", \"--logfile\", dest=\"logfile\", metavar=\"LOGFILE\",\n        default=None, type=\"string\", help=\"Log file\"\n    )\n    parser.add_option(\n        \"-p\", \"--skeleton-path\", dest=\"skeleton_path\", metavar=\"PATH\", default=SKELETON_DIR,\n        help=\"(Advanced) Path where the script looks for skeletons. \" +\n          \"The directory must contain sub directories named by \" +\n          \"the application types. (Default: %default)\"\n    )\n    parser.add_option(\n        \"--cache\", dest=\"cache\", metavar=\"PATH\", default=\"${TMPDIR}/qx${QOOXDOO_VERSION}/cache\",\n        help=\"Path to the cache directory; will be entered into config.json's CACHE macro (Default: %default)\"\n    )\n\n    (options, args) = parser.parse_args(sys.argv[1:])\n    options.name = \"testapp2\"\n    if not options.name:\n        parser.print_help()\n        sys.exit(1)\n    else:\n        options.name = options.name.decode('utf-8')\n\n    # Initialize console\n    global console\n    console = Log(options.logfile, \"info\")\n\n    checkNamespace(options)\n    getQxVersion()\n    createApplication(options)\n\n    console.log(\"DONE\")\n\n\npattern = r\"\"\"\n%(delim)s(?:\n  (?P<escaped>%(delim)s) |   # Escape sequence of two delimiters\n  (?P<named>%(id)s)      |   # delimiter and a Python identifier\n  {(?P<braced>%(id)s)}   |   # delimiter and a braced identifier\n  (?P<invalid>)              # Other ill-formed delimiter exprs\n)\n\"\"\"\n\nclass MyTemplate(Template):\n     #delimiter = \"%\"\n    pattern = r\"\"\"\n    \\$(?:\n      (?P<escaped>\\$) |   # Escape sequence of two delimiters\n      {(?P<braced>[_a-z][_a-z0-9]*)}   |   # delimiter and a braced identifier\n      (?P<invalid>)              # Other ill-formed delimiter exprs\n    )\n    \"\"\"\n     \n\n\nif __name__ == '__main__':\n    try:\n        main()\n\n    except KeyboardInterrupt:\n        print\n        print \"Keyboard interrupt!\"\n        sys.exit(1)\n"]],"start1":0,"start2":0,"length1":0,"length2":15029}]],"length":15029}
