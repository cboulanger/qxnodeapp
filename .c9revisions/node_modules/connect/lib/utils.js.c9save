{"ts":1344165544492,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Connect - utils\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar http = require('http')\n  , crypto = require('crypto')\n  , parse = require('url').parse\n  , Path = require('path')\n  , fs = require('fs');\n\n/**\n * Extract the mime type from the given request's\n * _Content-Type_ header.\n *\n * @param  {IncomingMessage} req\n * @return {String}\n * @api private\n */\n\nexports.mime = function(req) {\n  var str = req.headers['content-type'] || '';\n  return str.split(';')[0];\n};\n\n/**\n * Generate an `Error` from the given status `code`\n * and optional `msg`.\n *\n * @param {Number} code\n * @param {String} msg\n * @return {Error}\n * @api private\n */\n\nexports.error = function(code, msg){\n  var err = new Error(msg || http.STATUS_CODES[code]);\n  err.status = code;\n  return err;\n};\n\n/**\n * Return md5 hash of the given string and optional encoding,\n * defaulting to hex.\n *\n *     utils.md5('wahoo');\n *     // => \"e493298061761236c96b02ea6aa8a2ad\"\n *\n * @param {String} str\n * @param {String} encoding\n * @return {String}\n * @api private\n */\n\nexports.md5 = function(str, encoding){\n  return crypto\n    .createHash('md5')\n    .update(str)\n    .digest(encoding || 'hex');\n};\n\n/**\n * Merge object b with object a.\n *\n *     var a = { foo: 'bar' }\n *       , b = { bar: 'baz' };\n *     \n *     utils.merge(a, b);\n *     // => { foo: 'bar', bar: 'baz' }\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n * @api private\n */\n\nexports.merge = function(a, b){\n  if (a && b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function(html){\n  return String(html)\n    .replace(/&(?!\\w+;)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n\n/**\n * Return a unique identifier with the given `len`.\n *\n *     utils.uid(10);\n *     // => \"FDaS435D2z\"\n *\n * @param {Number} len\n * @return {String}\n * @api private\n */\n\nexports.uid = function(len) {\n  return crypto.randomBytes(Math.ceil(len * 3 / 4))\n    .toString('base64')\n    .slice(0, len);\n};\n\n/**\n * Sign the given `val` with `secret`.\n *\n * @param {String} val\n * @param {String} secret\n * @return {String}\n * @api private\n */\n\nexports.sign = function(val, secret){\n  return val + '.' + crypto\n    .createHmac('sha256', secret)\n    .update(val)\n    .digest('base64')\n    .replace(/=+$/, '');\n};\n\n/**\n * Unsign and decode the given `val` with `secret`,\n * returning `false` if the signature is invalid.\n *\n * @param {String} val\n * @param {String} secret\n * @return {String|Boolean}\n * @api private\n */\n\nexports.unsign = function(val, secret){\n  var str = val.slice(0, val.lastIndexOf('.'));\n  return exports.sign(str, secret) == val\n    ? str\n    : false;\n};\n\n/**\n * Parse signed cookies, returning an object\n * containing the decoded key/value pairs,\n * while removing the signed key from `obj`.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.parseSignedCookies = function(obj, secret){\n  var ret = {};\n  Object.keys(obj).forEach(function(key){\n    var val = obj[key];\n    if (0 == val.indexOf('s:')) {\n      val = exports.unsign(val.slice(2), secret);\n      if (val) {\n        ret[key] = val;\n        delete obj[key];\n      }\n    }\n  });\n  return ret;\n};\n\n/**\n * Parse a signed cookie string, return the decoded value\n *\n * @param {String} str signed cookie string\n * @param {String} secret\n * @return {String} decoded value\n * @api private\n */\n\nexports.parseSignedCookie = function(str, secret){\n  return 0 == str.indexOf('s:')\n    ? exports.unsign(str.slice(2), secret)\n    : str;\n};\n\n/**\n * Parse JSON cookies.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.parseJSONCookies = function(obj){\n  Object.keys(obj).forEach(function(key){\n    var val = obj[key];\n    var res = exports.parseJSONCookie(val);\n    if (res) obj[key] = res;\n  });\n  return obj;\n};\n\n/**\n * Parse JSON cookie string\n *\n * @param {String} str\n * @return {Object} Parsed object or null if not json cookie\n * @api private\n */\n\nexports.parseJSONCookie = function(str) {\n  if (0 == str.indexOf('j:')) {\n    try {\n      return JSON.parse(str.slice(2));\n    } catch (err) {\n      // no op\n    }\n  }\n}\n\n/**\n * Pause `data` and `end` events on the given `obj`.\n * Middleware performing async tasks _should_ utilize\n * this utility (or similar), to re-emit data once\n * the async operation has completed, otherwise these\n * events may be lost.\n *\n *      var pause = utils.pause(req);\n *      fs.readFile(path, function(){\n *         next();\n *         pause.resume();\n *      });\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.pause = require('pause');\n\n/**\n * Strip `Content-*` headers from `res`.\n *\n * @param {ServerResponse} res\n * @api private\n */\n\nexports.removeContentHeaders = function(res){\n  Object.keys(res._headers).forEach(function(field){\n    if (0 == field.indexOf('content')) {\n      res.removeHeader(field);\n    }\n  });\n};\n\n/**\n * Check if `req` is a conditional GET request.\n *\n * @param {IncomingMessage} req\n * @return {Boolean}\n * @api private\n */\n\nexports.conditionalGET = function(req) {\n  return req.headers['if-modified-since']\n    || req.headers['if-none-match'];\n};\n\n/**\n * Respond with 401 \"Unauthorized\".\n *\n * @param {ServerResponse} res\n * @param {String} realm\n * @api private\n */\n\nexports.unauthorized = function(res, realm) {\n  res.statusCode = 401;\n  res.setHeader('WWW-Authenticate', 'Basic realm=\"' + realm + '\"');\n  res.end('Unauthorized');\n};\n\n/**\n * Respond with 304 \"Not Modified\".\n *\n * @param {ServerResponse} res\n * @param {Object} headers\n * @api private\n */\n\nexports.notModified = function(res) {\n  exports.removeContentHeaders(res);\n  res.statusCode = 304;\n  res.end();\n};\n\n/**\n * Return an ETag in the form of `\"<size>-<mtime>\"`\n * from the given `stat`.\n *\n * @param {Object} stat\n * @return {String}\n * @api private\n */\n\nexports.etag = function(stat) {\n  return '\"' + stat.size + '-' + Number(stat.mtime) + '\"';\n};\n\n/**\n * Parse the given Cache-Control `str`.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.parseCacheControl = function(str){\n  var directives = str.split(',')\n    , obj = {};\n\n  for(var i = 0, len = directives.length; i < len; i++) {\n    var parts = directives[i].split('=')\n      , key = parts.shift().trim()\n      , val = parseInt(parts.shift(), 10);\n\n    obj[key] = isNaN(val) ? true : val;\n  }\n\n  return obj;\n};\n\n/**\n * Parse the `req` url with memoization.\n *\n * @param {ServerRequest} req\n * @return {Object}\n * @api private\n */\n\nexports.parseUrl = function(req){\n  var parsed = req._parsedUrl;\n  if (parsed && parsed.href == req.url) {\n    return parsed;\n  } else {\n    return req._parsedUrl = parse(req.url);\n  }\n};\n\n/**\n * Parse byte `size` string.\n *\n * @param {String} size\n * @return {Number}\n * @api private\n */\n\nexports.parseBytes = require('bytes');\n"]],"start1":0,"start2":0,"length1":0,"length2":7045}]],"length":7045}
