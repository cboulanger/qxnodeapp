{"ts":1342958089342,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n################################################################################\n#\n#  qooxdoo - the new era of web development\n#\n#  http://qooxdoo.org\n#\n#  Copyright:\n#    2008 - 2012 1&1 Internet AG, Germany, http://www.1und1.de\n#\n#  License:\n#    LGPL: http://www.gnu.org/licenses/lgpl.html\n#    EPL: http://www.eclipse.org/org/documents/epl-v10.php\n#    See the LICENSE file in the project's top-level directory for details.\n#\n#  Authors:\n#    * Thomas Herchenroeder (thron7)\n#\n################################################################################\n\n##\n# This is a stub proxy for the real generator.py\n##\n\nimport sys, os, re, subprocess, codecs, optparse\n\nCMD_PYTHON = sys.executable\nQOOXDOO_PATH = '../qooxdoo'\nQX_PYLIB = \"tool/pylib\"\n\n##\n# A derived OptionParser class that ignores unknown options (The parent\n# class raises in those cases, and stops further processing).\n# We need this, as we are only interested in -c/--config on this level, and\n# want to ignore pot. other options.\n#\nclass MyOptionParser(optparse.OptionParser):\n    ##\n    # <rargs> is the raw argument list. The original _process_args mutates\n    # rargs, processing options into <values> and copying interspersed args\n    # into <largs>. This overridden version ignores unknown or ambiguous \n    # options.\n    def _process_args(self, largs, rargs, values):\n        while rargs:\n            try:\n                optparse.OptionParser._process_args(self, largs, rargs, values)\n            except (optparse.BadOptionError, optparse.AmbiguousOptionError):\n                pass\n\n\ndef parseArgs():\n    parser = MyOptionParser()\n    parser.add_option(\n        \"-c\", \"--config\", dest=\"config\", metavar=\"CFGFILE\", \n        default=\"config.json\", help=\"path to configuration file\"\n    )\n    parser.add_option(\n        \"-v\", \"--verbose\", dest=\"verbose\", action=\"store_true\",\n        default=False, help=\"run in verbose mode\"\n    )\n    (options, args) = parser.parse_args(sys.argv[1:])\n    return options, args\n\nShellOptions, ShellArgs = parseArgs()\n\n\n# this is from misc.json, duplicated for decoupling\n_eolComment = re.compile(r'(?<![a-zA-Z]:)//.*$', re.M) # double $ for string.Template\n_mulComment = re.compile(r'/\\*.*?\\*/', re.S)\ndef stripComments(s):\n    b = _eolComment.sub('',s)\n    b = _mulComment.sub('',b)\n    return b\n\ndef getQxPath():\n    path = QOOXDOO_PATH\n    # OS env takes precedence\n    if os.environ.has_key(\"QOOXDOO_PATH\"):\n        path = os.environ[\"QOOXDOO_PATH\"]\n\n    # else use QOOXDOO_PATH from config.json\n    else:\n        config_file = ShellOptions.config\n        if os.path.exists(config_file):\n            # try json parsing with qx json\n            if not path.startswith('${'): # template macro has been resolved\n                sys.path.insert(0, os.path.join(path, QX_PYLIB))\n                try:\n                    from misc import json\n                    got_json = True\n                except:\n                    got_json = False\n\n            got_path = False\n            if got_json:\n                config_str = codecs.open(config_file, \"r\", \"utf-8\").read()\n                #config_str = stripComments(config_str)  # not necessary under demjson\n                config = json.loads(config_str)\n                p = config.get(\"let\")\n                if p:\n                    p = p.get(\"QOOXDOO_PATH\")\n                    if p:\n                        path = p\n                        got_path = True\n\n            # regex parsing - error prone\n            if not got_path:\n                qpathr=re.compile(r'\"QOOXDOO_PATH\"\\s*:\\s*\"([^\"]*)\"\\s*,?')\n                conffile = codecs.open(config_file, \"r\", \"utf-8\")\n                aconffile = conffile.readlines()\n                for line in aconffile:\n                    mo = qpathr.search(line)\n                    if mo:\n                        path = mo.group(1)\n                        break # assume first occurrence is ok\n\n    path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), path))\n\n    return path\n\nos.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))  # switch to skeleton dir\nqxpath = getQxPath()\nREAL_GENERATOR = os.path.join(qxpath, 'tool', 'bin', 'generator.py')\n\nif not os.path.exists(REAL_GENERATOR):\n    print \"Cannot find real generator script under: \\\"%s\\\"; aborting\" % REAL_GENERATOR\n    sys.exit(1)\nelif ShellOptions.verbose:\n    print \"\\nInvoking real generator under %s ...\" % REAL_GENERATOR\n\nargList = []\nargList.append(CMD_PYTHON)\nargList.append(REAL_GENERATOR)\nargList.extend(sys.argv[1:])\nif sys.platform == \"win32\":\n    argList1=[]\n    for arg in argList:\n        if arg.find(' ')>-1:\n            argList1.append('\"%s\"' % arg)\n        else:\n            argList1.append(arg)\n    argList = argList1\nelse:\n    argList = ['\"%s\"' % x for x in argList]  # quote argv elements\n    \ncmd = \" \".join(argList)\nretval = subprocess.call(cmd, shell=True)\nsys.exit(retval)\n"]],"start1":0,"start2":0,"length1":0,"length2":4935}]],"length":4935}
